题目描述
给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。

思路:第一种想法，中序遍历，将所有节点存储在动态数组中，然后return,但是这种要完整遍历所有的节点，时间有点长。
可以直接根据k值来找。
代码:
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.ArrayList;
public class Solution {
    ArrayList<TreeNode> list = new ArrayList<TreeNode>();
    public int length = 0;
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(pRoot == null || k == 0)
            return null;
        TreeNode head = pRoot;
        xianxu(head);
        if(k > length)
            return null;
        return list.get(k-1);
    }
	public void xianxu(TreeNode head){
        if(head == null)
            return;
        xianxu(head.left);
        list.add(head);
        length++;
        xianxu(head.right);
    }

}

更精简的代码:
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    int number = 0;
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(pRoot != null){
            TreeNode node = KthNode(pRoot.left, k);
            if(node != null) //为了确保在找到(number == k)的时候能逐层返回
                return node;
            number++;
            if(number == k)
                return pRoot;
            node = KthNode(pRoot.right, k);
            if(node != null)//node为根左右结构中的根时才不为NULL，node不为NULL，说明在左右的子树的-左根右结构的-根中已经找到！
                return node;
        }
        return null;
    }


}






